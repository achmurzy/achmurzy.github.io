---
layout: post
title:  "Second Attempt"
date:   2016-12-29 12:29:16 -0700
categories: games blog
---
 In the second semester of my sophmore year I began working on a second game. By then I had begun using a tool called Unity3D to graduate from 2D to 3D game environments. My impetus was
once again schoolwork; my failure from last time (barely completing five hours of coding with a worthless prototype) compelled me to redouble my efforts, without the needless anxiety. Scaling
back my vision I decided to completely focus on one thing: the way the player controls the character in the game. The environment would be rough and utilitarian--basically an obstacle course of
sorts for demonstrating the capabilities of the player's body. This was not my intial plan, but beginning to do (semi-)serious programming work in Unity3D more or less forced me away from
considering anything too consequential.
    I've more or less grown up as a programmer in Unity3D. This was where I did my first serious self-directed physical simulations, put the rubber to the road with concepts from computer
graphics, all in an object-oriented paradigm. This gave me a good idea of what the mainstream of programming is in our world. Looking back on my notes on Unity's "CharacterController" module, this
was a very arduous process, showing me just how much of a novice I was at the time: underlining data types for clarity, painstaking attempts at understanding what a state machine is, basic
graphical concepts like a visualization loop, windows, working with cameras, rendering geometry, dozens of pages of basic calculations in vector geometry (dot, cross, understanding arithmetic).
I had to teach myself some basic physics as well. Throughout I was able to drive myself pretty hard because I knew I was in the right place. Such concepts form the nuts and bolts of any attempt
to program an interesting physical experience in interactive entertainment.
    All of this is very much facilitated by the excellent interactive coding environment Unity3D provides. It is possible to immediately visualize the results of most important lines of code.
This is something I could do more often to this day: finding unfamiliar code and teasing it apart, line-by-line. This can be boring, or at least rouses my impatience. Programming, spitting out
line after line of code can be euphoric--studying code like this can feel like programming in slow-motion, backwards. In general my technical skills could use more discipline, and usually
benefit from slowing down and understanding the construction of a good piece of work.
    The entries in my journal slow down significantly in this period. Rather than reflecting in prose, most of this time was spent programming in a sloppy, furious state of creation. I would
not continue this pattern in my next project, instead painstakingly recording and keeping my designs, with a good balance between reflection, problem-solving and implementation. As my crash-course in Unity3D, this project did not produce much worth reflecting on: shoe-string code and a largely unplayable 3D platformer that I am proud of, as an act of will, to this day. 
