<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>Codex</title>
    <style>
      html, body { width: 100%; height: 100%; margin: 0px; }
      path { fill:black; fill-opacity:0.0; stroke: #000; stroke-width: 1px; stroke-opacity: 1;}
    </style>
  </head>
  <body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="opentype.min.js"></script>
    <script src="victor.min.js"></script>
    <script src="glyph_generator.js"></script>
    <script src="primitive_strokes.js"></script>
    <script>

      var glyphScale = 1000;
      var boxScale = 100;

      var margin = {top: 40, right: 40, bottom: 40, left: 40},
                        mWidth = 400, 
                        mHeight = 300;

      var canvas = d3.select("body").append("svg")
                .attr("class", "container")
                .attr("x", margin.left)
                .attr("y", margin.top)
                .attr("width", 2 * (mWidth + boxScale))
                .attr("height", 2 * (mHeight + boxScale));

      var drawGroup = canvas.append("g")
                .attr("x", 0)
                .attr("y", 0);

      var alphabetGroup = canvas.append("g")
                .attr("x", 0)
                .attr("y", 0)
                .attr("transform", "translate("+(mWidth+boxScale)+","+0+")");

      var glyphsX = mWidth / boxScale;
      var glyphsY = mHeight / boxScale;

      //Scale from glyph generation space to canvas space
      var x = d3.scaleLinear()
                .domain([0, glyphScale])
                .range([0, boxScale]);
      var y = d3.scaleLinear()
                .domain([0, glyphScale])
                .range([0, boxScale]);

      var gScaleX = d3.scaleLinear()
        .domain([0, glyphsX])
        .range([0, mWidth]);

      var gScaleY = d3.scaleLinear()
        .domain([0, glyphsY])
        .range([0, mHeight]);

      var glyphCounter = 0;
      var unicodeCounter = 61;

      var generationTime = 100;
      var drawDuration = 500;
      var expandedElement = Number.MAX_SAFE_INTEGER;
      var lastExpanded = expandedElement;

      var minStrokes = 2;
      var maxStrokes = 5;
      var codex = [];
      var strokeData = [];

      var alphabet = [];

      function addGlyph() 
      {
        if(strokeData.length >= glyphsX*glyphsY)
        {
          console.log("At glyph limit");   
          glyphGenerator.stop();

          /*codex.length = 0;
          strokeData.length = 0;
          codex = [];
          strokeData = [];*/
        }
        else
        {
          var glyph = generateGlyph(minStrokes+Math.floor(maxStrokes * Math.random()), 
                      glyphCounter, unicodeCounter);
          codex.push(glyph);
          strokeData.push(glyphToStrokes(glyph));   
          iterateUnicode();
          update(strokeData);
        }   
      }

      //setInterval(addGlyph, generationTime);
      var glyphGenerator = d3.interval(addGlyph, generationTime);

      //Generalize for multiple glyph panels (should work passing in alphabet data)
      function update(glyphStrokes)
      {
        //Use glyph index as a key function to uniquely identify glyphs
        var glyphs = drawGroup.selectAll("g").data(glyphStrokes, function(d, i) 
          { return d.index; });

        glyphs.exit().remove();

        //Update 
        glyphs.attr("class", "update");
        glyphs.selectAll("rect")
          .attr("class", "update")
          .on("click", function(d, i) //Update index for re-positioning 
                { 
                  var gElement = this.parentNode;
                  var positionIndex;
                  console.log("Rect index: "+d3.select(gElement).datum().index);
                  glyphs.each(function(d, i) 
                  {
                    console.log(d.index);
                    if(d.index === d3.select(gElement).datum().index)                    
                      positionIndex = i;
                  });
                  inspectGlyph(gElement, positionIndex);
                })
          .on("dblclick", function(d, i) //Update index for re-positioning 
                { 
                  var gElement = this.parentNode;
                  var positionIndex;
                  glyphs.each(function(d, i) 
                  {
                    console.log(d.index);
                    if(d.index === d3.select(gElement).datum().index)                    
                      positionIndex = i;
                  });
                  alphabetizeGlyph(gElement, positionIndex);
                });  

        //Get glyphs entering to assign a box directly to the group
        enterGlyphs = glyphs.enter()
          .append("g")
            .attr("class", "enter")
            .attr("transform", function(d, i) { return positionGlyph(i, expandedElement); });
        
        enterGlyphs.append("rect")
              .attr("x", 0)
              .attr("y", function(d, i) { return 0; })
              .attr("width", boxScale)
              .attr("height", boxScale)
              .attr("stroke", 'black')
              .style("fill-opacity", 0)
              .attr("fill", 'green')
              .style("fill-opacity", 0.35)
              .on("click", function(d, i) 
                { 
                  inspectGlyph(this.parentNode, i);
                })
              .on("dblclick", function(d, i)
                {
                  var gElement = d3.select(this.parentNode).remove();
                  alphabetizeGlyph(gElement, i);
                });

        //Merge with older glyphs to update strokes in one go
        enterGlyphs.merge(glyphs);
                 
        //We need to break the data down and add path elements 
        //one-by-one to visualize them effectively in d3's framework               
        var strokes = glyphs.selectAll("path").data(function(d, i) 
                          { return d.strokes; });
        strokes.attr("class", "update");
        strokes.enter()
          .append("path")  
            .attr("class", "enter")
            .style("fill-opacity", 0)      
            .style("stroke-opacity", 0)
            .attr("d", function(d) { return strokeInterpret(d.contours); })
            .style("stroke-dasharray", function(d) 
              { return this.getTotalLength(); })
            .style("stroke-dashoffset", function(d) 
              { return this.getTotalLength(); })
            .transition()
              .duration(drawDuration)
              .delay(function(d, i) { return drawDuration * i; })
              .ease(d3.easeLinear)
              .style("fill-opacity", 0.25)
              .style("stroke-opacity", 0.5)
              .style("stroke-dashoffset", function(d) 
              { return 0+"px"; });

        initGlyphData(glyphs);
      }

      //Positions glyph within an origin space
      function positionGlyph(index, element)
      {
        var offset = 0;
        if((element+1) % glyphsX === 0)
        {
          if(index > element + (glyphsX - 1))
          {
            offset = 1;
          }
        }
        else
        {
          if(index < element + (glyphsX - 1))
          {
            offset = 1;
          }
          else
          {
            offset = 3;
          }
        }   

        var gY = Math.floor((index+offset) / glyphsX);
        var gX = (offset+index) - (gY * glyphsX);
        
        return "translate(" + gScaleX(gX) + "," + gScaleY(gY) + ") scale(1,1)";
      }

      //These functions
      function collapse(i)
      {
        return parseTransform(positionGlyph(i, Number.MAX_SAFE_INTEGER));
      }

      //Are quite similar
      function expand(i)
      {  
        if(i >= expandedElement)
        {       
          if(i === expandedElement)
          { 
            var transform = parseTransform(positionGlyph(i, Number.MAX_SAFE_INTEGER));
            transform.scale = [2, 2];
            return transform;
          }
          else
          {
            return parseTransform(positionGlyph(i, expandedElement));
          }
        }
        else
        {
          return parseTransform(positionGlyph(i, Number.MAX_SAFE_INTEGER));
        }   
      }

      function interpolateTransform(t, startT, endT)
      {
        var is = d3.interpolateNumber(startT.scale[0], endT.scale[0]);
        var tsx = d3.interpolateNumber(startT.translate[0], endT.translate[0]);
        var tsy = d3.interpolateNumber(startT.translate[1], endT.translate[1]);
        newTrans = "translate("+tsx(t)+","+tsy(t)+"),scale("+is(t)+","+is(t)+")";
        return newTrans;
      }

      function parseTransform (a)
      {
          var b={};
          for (var i in a = a.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?)+\))+/g))
          {
              var c = a[i].match(/[\w\.\-]+/g);
              b[c.shift()] = c;
          }
          return b;
      }

      function inspectGlyph(gElement, i)
      {
        lastExpanded = expandedElement;
        var positionFunc;
        if(i === expandedElement) 
        {
          expandedElement = Number.MAX_SAFE_INTEGER;
          positionFunc = collapse;
        }
        else {
          expandedElement = i;
          positionFunc = expand;
          toggleGlyphData(d3.select(gElement), true);
        }

        var parentGroup = d3.select(gElement.parentNode);
        parentGroup.selectAll("g").each(function(d, i) 
        {
          var groupElement = d3.select(this);
          var startTransform = parseTransform(groupElement.attr("transform"));
          var endTransform = positionFunc(i); 
          if(i==lastExpanded)
            toggleGlyphData(groupElement, false);
          groupElement.transition()
            .attrTween("transform", function(t)
            {
              return function(t)
              { 
                return interpolateTransform(t, startTransform, endTransform);
              };
            });
        });
      }

      function alphabetizeGlyph(gElement, i)
      {
        var startTransform = parseTransform(gElement.attr("transform"));
        glyphStrokes.splice(i, 1);

        alphabetGroup.append(function() { return gElement.node(); });
        alphabet.push(gElement.datum());
        var endTransform = collapse(alphabet.length - 1);

        gElement.transition()
        .attrTween("transform", function(t)
            {
              return function(t)
              { 
                return interpolateTransform(t, startTransform, endTransform);
              };
            });
      }

      function toggleGlyphData(glyph, up)
      {
        var radius = up ? 2 : 0;
        
        //Draw stroke elements for interactive editing
        var startPoints = glyph.selectAll("circle.start").attr("r", radius);
        var endPoints = glyph.selectAll("circle.end").attr("r", radius);
        var controlPoints1 = glyph.selectAll("circle.control1").attr("r", radius);
        var controlPoints2 = glyph.selectAll("circle.control2").attr("r", radius);

        glyph.selectAll("path").transition()
          .style("fill", function(d) { if(up) return d.color; else return 'black'; })
          .style("stroke",function(d) { if(up) return d.color; else return 'black'; });
      }

      function strokeInterpret(datum)
      {
        var path = d3.path();
        for(var c = 0; c < datum.length; c++)
        {
          for(var i  = 0; i < datum.length; i++)
          {
            var point = datum[i];
            var pointX = x(point.x);
            var pointY = y(point.y);
            
            switch(point.type)
            {
              case 'M':
                path.moveTo(pointX, pointY);
                break;
              case 'L':
                path.lineTo(pointX, pointY);
                break ;
              case 'Q':
                path.quadraticCurveTo(x(point.x1), y(point.y1), pointX, pointY);
                break;
              case 'C':
                path.bezierCurveTo(x(point.x1), y(point.y1), 
                  x(point.x2), y(point.y2), pointX, pointY);
                break;
              case 'Z':                                    
                path.closePath();
                break;
              default:
                console.log("Uninterpretable symbol. Check path generation algorithm");
            }
          }
        }
        
        return path.toString();
      }

      function initGlyphData(glyphs)
      {
        //Draw stroke elements for interactive editing
        var startPoints = glyphs.selectAll("circle.start").data(function(d, i)
                            { return d.strokes; });
        startPoints.enter()
          .append("circle")
            .attr("class", "start")
            .attr("cx", function(d) { return x(d.start.x); })
            .attr("cy", function(d) { return y(d.start.y); })
            .attr("r", 0)
            .style("fill", function(d) { return d.color; })
            .style("stroke", 'black');

        var endPoints = glyphs.selectAll("circle.end").data(function(d, i)
                            { return d.strokes; });
        endPoints.enter()
          .append("circle")
            .attr("class", "end")
            .attr("cx", function(d) { return x(d.end.x); })
            .attr("cy", function(d) { return y(d.end.y); })
            .attr("r", 0)
            .style("fill", function(d) { return d.color; })
            .style("stroke", 'black');

        var controlPoints1 = glyphs.selectAll("circle.control1").data(function(d, i)
                            { return d.strokes; });
        controlPoints1.enter()
          .append("circle")
            .attr("class", "control1")
            .attr("cx", function(d) 
              { if(d.cp1 != undefined) return x(d.cp1.x); else return 0; })
            .attr("cy", function(d) 
              { if(d.cp1 != undefined) return y(d.cp1.y); else return 0; })
            .attr("r", function(d) 
              { if(d.cp1 != undefined) return 0; else return 0; })
            .style("fill", function(d) { return d.color; })
            .style("stroke", 'white');

        var controlPoints2 = glyphs.selectAll("circle.control2").data(function(d, i)
                            { return d.strokes; });
        controlPoints2.enter()
          .append("circle")
            .attr("class", "control2")
            .attr("cx", function(d) 
              { if(d.cp2 != undefined) return x(d.cp2.x); else return 0; })
            .attr("cy", function(d) 
              { if(d.cp2 != undefined) return y(d.cp2.y); else return 0; })
            .attr("r", function(d) 
              { if(d.cp2 != undefined) return 0; else return 0; })
            .style("fill", function(d) { return d.color; })
            .style("stroke", 'white');
      }

            //Cut glyphs into strokes separated by 'M' symbols
      function glyphsToStrokes(glyphData)
      {
        var strokeData = [];
        for(var i = 0; i < glyphData.length; i++)
        {
          strokeData[i] = glyphToStrokes(glyphData[i]);
        }
        return strokeData;
      }

      //Takes an <opentype.js> Glyph object and converts it into an array of stroke data
      //While we're here, mirror points across the y-axis since computer graphics is
      //fuckin retarded
      function glyphToStrokes(glyphData)
      {
        var glyphObject = new Object();
        glyphObject.strokes = [];
        glyphObject.index = glyphData.index;

        //Loop through stroke data and access path list as needed
        for(var i = 0; i < glyphData.strokeData.length; i++)
        {
          var strokeObject = new Object();
          strokeObject.color = glyphData.strokeData[i].color;
          strokeObject.contours = [];

          var flipStart = JSON.parse(JSON.stringify(glyphData.strokeData[i].start));
          flipStart.y = MirrorY(flipStart.y);
          strokeObject.start = flipStart;

          var flipEnd = JSON.parse(JSON.stringify(glyphData.strokeData[i].end));
          flipEnd.y = MirrorY(flipEnd.y);
          strokeObject.end = flipEnd;

          //Exactly 5 path symbols per stroke: MLXLX, where X is L | Q | C
          for(var j = 0; j < 5; j++)
          {
            var flipPoint = JSON.parse(JSON.stringify(glyphData.path.commands[(i*5)+j]));
            if(flipPoint.type === 'Q' || flipPoint.type === 'C')
            {
              flipPoint.y1 = MirrorY(flipPoint.y1);
              
              var flipCp1 = JSON.parse(JSON.stringify(glyphData.strokeData[i].cp1));
              flipCp1.y = MirrorY(flipCp1.y);
              strokeObject.cp1 = flipCp1;

              if(flipPoint.type === 'C')
              {
                flipPoint.y2 = MirrorY(flipPoint.y2);

                var flipCp2 = JSON.parse(JSON.stringify(glyphData.strokeData[i].cp2));
                flipCp2.y = MirrorY(flipCp2.y);
                strokeObject.cp2 = flipCp2;
              }
            }
            flipPoint.y = MirrorY(flipPoint.y);
            strokeObject.contours.push(flipPoint);
          }

          glyphObject.strokes.push(strokeObject);
        }

        return glyphObject;
      }

      //A function to organize how glyphs fill the standard unicode symbol table
      //We start with lower-case roman letters, move to upper case, who know what then
      function iterateUnicode()
      {
        glyphCounter++;
        unicodeCounter++;
        if(unicodeCounter == 81)
        {
          unicodeCounter = 41;
        }
      }

      function buildFont(glyphData)
      {
        var font = new opentype.Font({
        familyName: 'OpenTypeSans',
        styleName: 'Medium',
        unitsPerEm: 1000,
        ascender: 800,
        descender: -200,
        glyphs: glyphData });
      
        console.log(font);

        fontJSON = JSON.stringify(font, function(key, value)
          {
            if(key === 'font')
              return undefined;
            return value;
          });
        
        if(/Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor))
          font.download();
      }

      //buildFont();
    </script>
  </body>
</html>
